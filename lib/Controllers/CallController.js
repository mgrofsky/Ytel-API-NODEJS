/**
 * YtelAPIV3Lib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class CallController {
    /**
     * Retrieve a single voice call’s information by its CallSid.
     *
     * @param {string} callSid The unique identifier for the voice call.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createViewCall1(callSid, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/viewcalldetail.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            callSid,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Retrieve a single voice call’s information by its CallSid.
     *
     * @param {string} callsid The unique identifier for the voice call.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createViewCall(callsid, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/viewcalls.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            callsid,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Play Dtmf and send the Digit
     *
     * @param {string} callSid The unique identifier of each call resource
     * @param {string} playDtmf DTMF digits to play to the call. 0-9, #, *, W, or w
     * @param {PlayDtmfDirectionEnum} playDtmfDirection (optional) The leg of the call DTMF digits
     * should be sent to
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createPlayDTMF(callSid, playDtmf, playDtmfDirection, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/senddigits.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            CallSid: callSid,
            PlayDtmf: playDtmf,
            PlayDtmfDirection: (playDtmfDirection !== null) ? playDtmfDirection : null,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * You can experiment with initiating a call through Ytel and view the request response
     * generated when doing so and get the response in json
     *
     * @param {string} from A valid Ytel Voice enabled number (E.164 format) that will be
     * initiating the phone call.
     * @param {string} to To number
     * @param {string} url URL requested once the call connects
     * @param {string} method (optional) Specifies the HTTP method used to request the required URL
     * once call connects.
     * @param {string} statusCallBackUrl (optional) URL that can be requested to receive
     * notification when call has ended. A set of default
     * parameters will be sent here once the call is finished.
     * @param {string} statusCallBackMethod (optional) Specifies the HTTP methodlinkclass used to
     * request StatusCallbackUrl.
     * @param {string} fallBackUrl (optional) URL requested if the initial Url parameter fails or
     * encounters an error
     * @param {string} fallBackMethod (optional) Specifies the HTTP method used to request the
     * required FallbackUrl once call connects.
     * @param {string} heartBeatUrl (optional) URL that can be requested every 60 seconds during
     * the call to notify of elapsed tim
     * @param {string} heartBeatMethod (optional) Specifies the HTTP method used to request
     * HeartbeatUrl.
     * @param {int} timeout (optional) Time (in seconds) Ytel should wait while the call is ringing
     * before canceling the call
     * @param {string} playDtmf (optional) DTMF Digits to play to the call once it connects. 0-9, #,
     * or *
     * @param {bool} hideCallerId (optional) Specifies if the caller id will be hidden
     * @param {bool} record (optional) Specifies if the call should be recorded
     * @param {string} recordCallBackUrl (optional) Recording parameters will be sent here upon
     * completion
     * @param {string} recordCallBackMethod (optional) Method used to request the RecordCallback
     * URL.
     * @param {bool} transcribe (optional) Specifies if the call recording should be transcribed
     * @param {string} transcribeCallBackUrl (optional) Transcription parameters will be sent here
     * upon completion
     * @param {IfMachineEnum} ifMachine (optional) How Ytel should handle the receiving numbers
     * voicemail machine
     * @param {string} ifMachineUrl (optional) URL requested when IfMachine=continue
     * @param {string} ifMachineMethod (optional) Method used to request the IfMachineUrl.
     * @param {bool} feedback (optional) Specify if survey should be enable or not
     * @param {string} surveyId (optional) The unique identifier for the survey.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createMakeCall(from,
        to,
        url,
        method,
        statusCallBackUrl,
        statusCallBackMethod,
        fallBackUrl,
        fallBackMethod,
        heartBeatUrl,
        heartBeatMethod,
        timeout,
        playDtmf,
        hideCallerId,
        record,
        recordCallBackUrl,
        recordCallBackMethod,
        transcribe,
        transcribeCallBackUrl,
        ifMachine,
        ifMachineUrl,
        ifMachineMethod,
        feedback,
        surveyId,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/makecall.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            From: from,
            To: to,
            Url: url,
            Method: method,
            StatusCallBackUrl: statusCallBackUrl,
            StatusCallBackMethod: statusCallBackMethod,
            FallBackUrl: fallBackUrl,
            FallBackMethod: fallBackMethod,
            HeartBeatUrl: heartBeatUrl,
            HeartBeatMethod: heartBeatMethod,
            Timeout: timeout,
            PlayDtmf: playDtmf,
            HideCallerId: hideCallerId,
            Record: record,
            RecordCallBackUrl: recordCallBackUrl,
            RecordCallBackMethod: recordCallBackMethod,
            Transcribe: transcribe,
            TranscribeCallBackUrl: transcribeCallBackUrl,
            IfMachine: (ifMachine !== null) ? ifMachine : null,
            IfMachineUrl: ifMachineUrl,
            IfMachineMethod: ifMachineMethod,
            Feedback: feedback,
            SurveyId: surveyId,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Play Audio from a url
     *
     * @param {string} callSid The unique identifier of each call resource
     * @param {string} audioUrl URL to sound that should be played. You also can add more than one
     * audio file using semicolons e.g. http://example.com/audio1.mp3;http:
     * //example.com/audio2.wav
     * @param {string} sayText Valid alphanumeric string that should be played to the In-progress
     * call.
     * @param {int} length (optional) Time limit in seconds for audio play back
     * @param {DirectionEnum} direction (optional) The leg of the call audio will be played to
     * @param {bool} mix (optional) If false, all other audio will be muted
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createPlayAudio(callSid, audioUrl, sayText, length, direction, mix, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/playaudios.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            CallSid: callSid,
            AudioUrl: audioUrl,
            SayText: sayText,
            Length: length,
            Direction: (direction !== null) ? direction : null,
            Mix: mix,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Start or stop recording of an in-progress voice call.
     *
     * @param {string} callSid The unique identifier of each call resource
     * @param {bool} record Set true to initiate recording or false to terminate recording
     * @param {Direction4Enum} direction (optional) The leg of the call to record
     * @param {int} timeLimit (optional) Time in seconds the recording duration should not exceed
     * @param {string} callBackUrl (optional) URL consulted after the recording completes
     * @param {FileformatEnum} fileformat (optional) Format of the recording file. Can be .mp3 or .
     * wav
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createRecordCall(callSid,
        record,
        direction,
        timeLimit,
        callBackUrl,
        fileformat,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/recordcalls.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            CallSid: callSid,
            Record: record,
            Direction: (direction !== null) ? direction : null,
            TimeLimit: timeLimit,
            CallBackUrl: callBackUrl,
            Fileformat: (fileformat !== null) ? fileformat : null,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Add audio voice effects to the an in-progress voice call.
     *
     * @param {string} callSid The unique identifier for the in-progress voice call.
     * @param {AudioDirectionEnum} audioDirection (optional) The direction the audio effect should
     * be placed on. If IN, the effects will occur on
     * the incoming audio stream. If OUT, the effects
     * will occur on the outgoing audio stream.
     * @param {double} pitchSemiTones (optional) Set the pitch in semitone (half-step) intervals.
     * Value between -14 and 14
     * @param {double} pitchOctaves (optional) Set the pitch in octave intervals.. Value between -1
     * and 1
     * @param {double} pitch (optional) Set the pitch (lowness/highness) of the audio. The higher
     * the value, the higher the pitch. Value greater than 0
     * @param {double} rate (optional) Set the rate for audio. The lower the value, the lower the
     * rate. value greater than 0
     * @param {double} tempo (optional) Set the tempo (speed) of the audio. A higher value denotes
     * a faster tempo. Value greater than 0
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createVoiceEffect(callSid,
        audioDirection,
        pitchSemiTones,
        pitchOctaves,
        pitch,
        rate,
        tempo,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/voiceeffect.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            CallSid: callSid,
            AudioDirection: (audioDirection !== null) ? audioDirection : null,
            PitchSemiTones: pitchSemiTones,
            PitchOctaves: pitchOctaves,
            Pitch: pitch,
            Rate: rate,
            Tempo: tempo,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Interrupt the Call by Call Sid
     *
     * @param {string} callSid The unique identifier for voice call that is in progress.
     * @param {string} url (optional) URL the in-progress call will be redirected to
     * @param {string} method (optional) The method used to request the above Url parameter
     * @param {StatusEnum} status (optional) Status to set the in-progress call to
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createInterruptCall(callSid, url, method, status, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/interruptcalls.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            CallSid: callSid,
            Url: url,
            Method: method,
            Status: (status !== null) ? status : null,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A list of calls associated with your Ytel account
     *
     * @param {int} page (optional) The page count to retrieve from the total results in the
     * collection. Page indexing starts at 1.
     * @param {int} pageSize (optional) Number of individual resources listed in the response per
     * page
     * @param {string} to (optional) Filter calls that were sent to this 10-digit number (E.164
     * format).
     * @param {string} from (optional) Filter calls that were sent from this 10-digit number (E.164
     * format).
     * @param {string} dateCreated (optional) Return calls that are from a specified date.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createListCalls(page, pageSize, to, from, dateCreated, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/listcalls.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            Page: page,
            PageSize: pageSize,
            To: to,
            From: from,
            DateCreated: dateCreated,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Initiate an outbound Ringless Voicemail through Ytel.
     *
     * @param {string} from A valid Ytel Voice enabled number (E.164 format) that will be
     * initiating the phone call.
     * @param {string} rVMCallerId A required secondary Caller ID for RVM to work.
     * @param {string} to A valid number (E.164 format) that will receive the phone call.
     * @param {string} voiceMailURL The URL requested once the RVM connects. A set of default
     * parameters will be sent here.
     * @param {string} method (optional) Specifies the HTTP method used to request the required URL
     * once call connects.
     * @param {string} statusCallBackUrl (optional) URL that can be requested to receive
     * notification when call has ended. A set of default
     * parameters will be sent here once the call is finished.
     * @param {string} statsCallBackMethod (optional) Specifies the HTTP method used to request the
     * required StatusCallBackUrl once call connects.
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createSendRVM(from,
        rVMCallerId,
        to,
        voiceMailURL,
        method,
        statusCallBackUrl,
        statsCallBackMethod,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/makervm.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            From: from,
            RVMCallerId: rVMCallerId,
            To: to,
            VoiceMailURL: voiceMailURL,
            Method: method,
            StatusCallBackUrl: statusCallBackUrl,
            StatsCallBackMethod: statsCallBackMethod,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Group Call
     *
     * @param {string} from This number to display on Caller ID as calling
     * @param {string} to Please enter multiple E164 number. You can add max 10 numbers. Add
     * numbers separated with comma. e.g : 1111111111,2222222222
     * @param {string} url URL requested once the call connects
     * @param {string} groupConfirmKey Define the DTMF that the called party should send to bridge
     * the call. Allowed Values : 0-9, #, *
     * @param {GroupConfirmFileEnum} groupConfirmFile Specify the audio file you want to play when
     * the called party picks up the call
     * @param {string} method (optional) Specifies the HTTP method used to request the required URL
     * once call connects.
     * @param {string} statusCallBackUrl (optional) URL that can be requested to receive
     * notification when call has ended. A set of default
     * parameters will be sent here once the call is finished.
     * @param {string} statusCallBackMethod (optional) Specifies the HTTP methodlinkclass used to
     * request StatusCallbackUrl.
     * @param {string} fallBackUrl (optional) URL requested if the initial Url parameter fails or
     * encounters an error
     * @param {string} fallBackMethod (optional) Specifies the HTTP method used to request the
     * required FallbackUrl once call connects.
     * @param {string} heartBeatUrl (optional) URL that can be requested every 60 seconds during
     * the call to notify of elapsed time and pass other general
     * information.
     * @param {string} heartBeatMethod (optional) Specifies the HTTP method used to request
     * HeartbeatUrl.
     * @param {int} timeout (optional) Time (in seconds) we should wait while the call is ringing
     * before canceling the call
     * @param {string} playDtmf (optional) DTMF Digits to play to the call once it connects. 0-9, #,
     * or *
     * @param {string} hideCallerId (optional) Specifies if the caller id will be hidden
     * @param {bool} record (optional) Specifies if the call should be recorded
     * @param {string} recordCallBackUrl (optional) Recording parameters will be sent here upon
     * completion
     * @param {string} recordCallBackMethod (optional) Method used to request the RecordCallback
     * URL.
     * @param {bool} transcribe (optional) Specifies if the call recording should be transcribed
     * @param {string} transcribeCallBackUrl (optional) Transcription parameters will be sent here
     * upon completion
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createGroupCall(from,
        to,
        url,
        groupConfirmKey,
        groupConfirmFile,
        method,
        statusCallBackUrl,
        statusCallBackMethod,
        fallBackUrl,
        fallBackMethod,
        heartBeatUrl,
        heartBeatMethod,
        timeout,
        playDtmf,
        hideCallerId,
        record,
        recordCallBackUrl,
        recordCallBackMethod,
        transcribe,
        transcribeCallBackUrl,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _queryBuilder = `${_baseUri}${'/calls/groupcall.json'}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'user-agent': 'APIMATIC 2.0',
        };

        // prepare form data
        const _form = {
            From: from,
            To: to,
            Url: url,
            GroupConfirmKey: groupConfirmKey,
            GroupConfirmFile: (groupConfirmFile !== null) ? groupConfirmFile : null,
            Method: method,
            StatusCallBackUrl: statusCallBackUrl,
            StatusCallBackMethod: statusCallBackMethod,
            FallBackUrl: fallBackUrl,
            FallBackMethod: fallBackMethod,
            HeartBeatUrl: heartBeatUrl,
            HeartBeatMethod: heartBeatMethod,
            Timeout: timeout,
            PlayDtmf: playDtmf,
            HideCallerId: hideCallerId,
            Record: record,
            RecordCallBackUrl: recordCallBackUrl,
            RecordCallBackMethod: recordCallBackMethod,
            Transcribe: transcribe,
            TranscribeCallBackUrl: transcribeCallBackUrl,
        };

        // remove null values
        _apiHelper.cleanObject(_form);

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            form: _form,
            username: _configuration.basicAuthUserName,
            password: _configuration.basicAuthPassword,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = CallController;
